{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"template": {
		"prefix": "temp",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"#define rep(i,n) for(int i=0;i<(n);i++)",
			"#define all(a) a.begin(),a.end()",
			"#define rall(a) a.rbegin(),a.rend()",
			"#define YES cout<<\"Yes\"<<endl",
			"#define NO cout<<\"No\"<<endl",
			"using ll=long long;",
			"using pi=pair<int,int>;",
			"const int di[]={+1,-1,+0,+0};",
			"const int dj[]={+0,+0,+1,-1};",
			"const int INF=1e9;",
			"int main() {",
			"\tios::sync_with_stdio(false);",
			"\tcin.tie(nullptr);",
			"\t$1",
			"",
			"\treturn 0;",
			"}"
		],
		"description": "This is proc's template"
	},
	/*
	"ACL's template": {
		"prefix": "tempacl",
		"body": [
			"#include <bits/stdc++.h>",
			"#include <atcoder/all>",
			"using namespace std;",
			"using namespace atcoder;",
			"#define rep(i, n) for(int i=0;i<(n);i++)",
			"#define all(a) a.begin(), a.end()",
			"#define rall(a) a.rbegin(), a.rend()",
			"using ll = long long;",
			"using pi = pair<int, int>;",
			"const int di[]={1,-1,0,0};",
			"const int dj[]={0,0,1,-1};",
			"const int INF=1e9;",
			"int main(){",
			"\tios::sync_with_stdio(false);",
			"\tcin.tie(nullptr);",
			"\t$1",
			"",
			"\treturn 0;",
			"}"
		],
		"description": "This is ACL's template"
	},
	*/
	"LCM": {
		"prefix": "lcm",
		"body": [
			"auto lcm=[&](ll a, ll b) {",
			"\tll d=__gcd(a, b);",
			"\treturn a/d*b;",
			"};"
		],
		"description": "This is lcm's template"
	},
	"nCr": {
		"prefix": "nCr",
		"body": [
			"const int MAX=1e6;",
			"vector<mint> fact(MAX), invfact(MAX);",
			"fact[0]=1;",
			"for(int i=1;i<MAX;i++){",
			"\tfact[i]=fact[i-1]*i;",
			"}",
			"invfact[MAX-1]=fact[MAX-1].inv();",
			"for(int i=MAX-1;1<=i;i--){",
			"\tinvfact[i-1]=invfact[i]*i;",
			"}",
			"auto nCr=[&](int n, int r) -> mint {",
			"\tif(r<0||r>n) return 0;",
			"\treturn fact[n]*invfact[r]*invfact[n-r];",
			"};",
		],
		"description": "This is comb's template"
	},
	"change maximum function": {
		"prefix": "chanmax",
		"body": [
			"template<class T> inline bool chmax(T& a, T b) {",
			"\tif(a<b) { a=b; return true; }",
			"\treturn false;",
			"}"
		],
		"description": "This is chmax function's template"
	},
	"change minimum function": {
		"prefix": "chanmin",
		"body": [
			"template<class T> inline bool chmin(T& a, T b) {",
			"\tif(a>b) { a=b; return true; }",
			"\treturn false;",
			"}"
		],
		"description": "This is chmin function's template"
	},
	"": {
		"prefix": "cal_next",
		"body": [
    		"//nex[i][c] i文字目以降でcが出現する最小の添字",
    		"auto cal_next=[&](const string &s) {",
    		"\tint n=(int)s.size();",
    		"\tvector<vector<int>> res(n+1, vector<int>(26, n));",
    		"\tfor (int i=n-1;0<=i;i--) {",
    		"\t\tres[i]=res[i+1];",
    		"\t\tres[i][s[i]-'a']=i;",
    		"\t}",
    		"\treturn res;",
    		"};"
		],
		"description": "This is calculate_next's template"
	},
	"Modint": {
		"prefix": "modint",
		"body": [
			"#include <atcoder/modint>",
			"using namespace atcoder;",
			"using mint=modint998244353;"
		],
		"description": "This is modint's template"
	},
	"Disjoint Set Union": {
		"prefix": "dsu",
		"body": [
			"#include <atcoder/dsu>",
			"using namespace atcoder;",
			"//dsu uf(n);"
		],
		"description": "This is dsu's template"
	},
	"Sieve of Eratosthenes": {
		"prefix": "eratos",
		"body": [
			"#include <atcoder/prime>",
			"using namespace atcoder;",
			"//Sieve p(n);"
		],
		"description": "This is dsu's template"
	},
	"Segment Tree(max)": {
		"prefix": "segtree/max",
		"body": [
			"#include <atcoder/segtree>",
			"using namespace atcoder;",
			"int op(int a, int b) { return max(a, b); }",
			"int e() { return 0; }",
			"//segtree<int, op, e> seg(n);"
		],
		"description": "This is segment Tree(max)'s template"
	},
	"Segment Tree(min)": {
		"prefix": "segtree/min",
		"body": [
			"#include <atcoder/segtree>",
			"using namespace atcoder;",
			"int op(int a, int b) { return min(a, b); }",
			"int e() { return INF; }",
			"//segtree<int, op, e> seg(n);"

		],
		"description": "This is segment Tree(min)'s template"
	},
	"Lazy segtree(add/max)": {
		"prefix": "lazy/add/max",
		"body": [
			"#include <atcoder/lazysegtree>",
			"using namespace atcoder;",
			"using S=long long;",
			"using F=long long;",
			"const S INF=1LL<<60;",
			"S op(S a, S b){ return max(a, b); }",
			"S e(){ return -INF; }",
			"S mapping(F f, S x){ return f+x; }",
			"F composition(F f, F g){ return f+g; }",
			"F id(){ return 0; }",
			"//lazy_segtree<S, op, e, F, mapping, composition, id> seg(n);"
		],
		"description": "This is Lazy segtree(add/max)'s template"
	},
	"Lazy segtree(add/min)": {
		"prefix": "lazy/add/min",
		"body": [
			"#include <atcoder/lazysegtree>",
			"using namespace atcoder;",
			"using S=long long;",
			"using F=long long;",
			"const S INF=1LL<<60;",
			"S op(S a, S b){ return min(a, b); }",
			"S e(){ return INF; }",
			"S mapping(F f, S x){ return f+x; }",
			"F composition(F f, F g){ return f+g; }",
			"F id(){ return 0; }",
			"//lazy_segtree<S, op, e, F, mapping, composition, id> seg(n);"
		],
		"description": "This is Lazy segtree(add/min)'s template"
	},
	"Lazy segtree(add/sum)": {
	    "prefix": "lazy/add/sum",
	    "body": [
	        "#include <atcoder/lazysegtree>",
	        "using namespace atcoder;",
	        "struct S {",
	        "\tlong long value;",
	        "\tint size;",
	        "};",
	        "using F=long long;",
	        "S op(S a, S b) { return {a.value + b.value, a.size + b.size}; }",
	        "S e() { return {0, 0}; }",
	        "S mapping(F f, S x) { return {x.value + f * x.size, x.size}; }",
	        "F composition(F f, F g) { return f + g; }",
	        "F id() { return 0; }",
			"vector<S> z(n, {0, 1});",
			"//lazy_segtree<S, op, e, F, mapping, composition, id> seg(z);"
	    ],
	    "description": "This is Lazy segtree(add/sum)'s template"
	},
	"Lazy segtree(assign/max)": {
	    "prefix": "lazy/assign/max",
	    "body": [
	        "#include <atcoder/lazysegtree>",
	        "using namespace atcoder;",
			"using S=long long;",
			"using F=long long;",
			"const S INF=1LL<<60;",
			"const F ID=1LL<<60;",
			"S op(S a, S b){ return max(a, b); }",
			"S e(){ return -INF; }",
			"S mapping(F f, S x){ return (f==ID ? x:f); }",
			"F composition(F f, F g){ return (f==ID ? g:f); }",
			"F id(){ return ID; }",
			"//lazy_segtree<S, op, e, F, mapping, composition, id> seg(n);"
	    ],
	    "description": "This is Lazy segtree(assign/max)'s template"
	},
	"Lazy segtree(assign/min)": {
	    "prefix": "lazy/assign/min",
	    "body": [
	        "#include <atcoder/lazysegtree>",
	        "using namespace atcoder;",
			"using S=long long;",
			"using F=long long;",
			"const S INF=1L<<60;",
			"const F ID=1LL<<60;",
			"S op(S a, S b){ return min(a, b); }",
			"S e(){ return INF; }",
			"S mapping(F f, S x){ return (f==ID ? x:f); }",
			"F composition(F f, F g){ return (f==ID ? g:f); }",
			"F id(){ return ID; }",
			"//lazy_segtree<S, op, e, F, mapping, composition, id> seg(n);"
	    ],
	    "description": "This is Lazy segtree(assign/min)'s template"
	},
	"Lazy segtree(assign/sum)": {
	    "prefix": "lazy/assign/sum",
	    "body": [
	        "#include <atcoder/lazysegtree>",
	        "using namespace atcoder;",
			"struct S {",
			"\tlong long value;",
			"\tint size;",
			"};",
			"using F=long long;",
			"const F ID=8e18;",
			"S op(S a, S b) { return {a.value+b.value, a.size+b.size}; }",
			"S e() { return {0, 0}; }",
			"S mapping(F f, S x) {",
			"\tif (f!=ID) x.value=f*x.size;",
			"\treturn x;",
			"}",
			"F composition(F f, F g) { return (f==ID ? g:f); }",
			"F id() { return ID; }",
			"vector<S> z(n, {0, 1});",
			"//lazy_segtree<S, op, e, F, mapping, composition, id> seg(z);"
	    ],
	    "description": "This is Lazy segtree(assign/sum)'s template"
	},
	"z-argorithm": {
	    "prefix": "z-algo",
	    "body": [
	        "#include <atcoder/string>",
	        "using namespace atcoder;",
			"//vector<int> z=z_algorithm(t);"
	    ],
	    "description": "This is z-algorithm's template"
	},
}
